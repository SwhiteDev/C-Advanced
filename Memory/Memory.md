# 对于内存的思考
## 数据段和堆
* 就像个堆栈段能够根据需要自动增长一样，数据段页包含了一个对象，用于完成这个任务，这就是堆(heap)。
* 堆区域用于动态分配的存储，也就是通过malloc()函数获得内存，并通过指针访问。堆中所有的东西都是匿名的
 ————不能按照名字直接访问，只能通过指针间接访问。从堆中获取内存的唯一办法就是通过调用malloc(以及同类
 的calloc、realloc等)库函数。
>calloc函数和malloc类似，但它在返回指针之前先把分配好的内存内容清零。<br/>
 realloc函数改变一个指针所指向的内存块的大小。<br/>
* 堆内存的回收不必与它所分配的顺序一致(甚至可以不回收)，所以无序的malloc/free最终会产生堆碎片。
* 堆的末端由一个break的指针来标识。当堆需要更多内存时，可以通过系统调用brk和sbrk来移动break指针。
>你的程序可能无法同时调用malloc()和brk()。如果你使用malloc，malloc希望当你调用brk和sbrk时，它具有
 唯一的控制权。由于sbrk向进程提供了唯一的方法将数据段内存返回给系统内核，所以如果使用了malloc就有效的
 防止了程序的数据段缩小的可能性。<br/>
 要想获得以后能够返回给系统内核的内存，可以使用mmap系统调用来映射/dev/zero文件。需要返回这种内存时，
 可以使用munmap系统调用。
## 内存泄漏
C语言通常并不使用垃圾回收器，这些C程序在使用malloc()和free()时，堆常会出现两种类型问题：
* 释放或改写正在使用的内存(称为“内存损坏”)。
* 未释放不再使用的内存(称为“内存泄漏”)。
>使用alloca()可以避免内存泄漏，当离开调用alloca的函数时，它所分配的内存自动释放(不提倡!)
### 检测内存泄漏
1. 使用swap、netstat、vmstat命令观察是否有内存不断被分配且从不释放。
2. 使用”pa -lu 用户名“命令来显示所有进程大小，查看是否有进程不断增长而从不缩小
## 总线错误
常见运行错误：
`bus error(core dumped)    总线错误(信息已转储)`<br/>
`segmentation fault(core dumped)    段错误(信息已转储)`<br/>
### 总线错误
* 总线错误几乎都是由于未对齐的读或写引起的。之所以称为“总线错误”是因为出现未对齐的内存访问请求时，被堵塞的组件就是
